## 前端监控面试

#### 统计了那些数据，为什么不用开源平台？ 开源平台有哪些？

**性能相关的数据**

 fcp,lcp,fp,ttfi, onload, domcontentLoade

**静态资源的加载**

- ajax请求耗时处理

- 错误相关的数据

- 资源加载错误

 **promise async await  错误** 

**行为监控**

- Pv Uv

- 页面停留的时长

- 用户行为click事件

开源的平台比较重，使用成本较高， 不好自定义数据，也不好拓展数据，也就是不够灵活！

开源的平台

```json
- Sentry：一个流行的开源错误捕获和上报库，提供了完整的错误上报和跟踪功能。
- Bugsnag：另一个常用的错误捕获和上报库，提供了实时错误通知和可视化分析等功能。
- Raygun：一个专业的错误监测和分析平台，提供了多种编程语言的错误监测和分析功能。
```

 阿里的A MRS前端监控， 百度统计，神策数据等

#### js信息如何统计？框架的错误如何统计？ 

##### js 信息统计方式?

##### 性能数据统计

fcp

```js
import { lazyReportBatch } from '../report'
export default function observeFCP() {
  const entryhandler = (list) => {
    for (const entry of list.getEntries()) {
      if (entry.name === 'first-contentful-paint') {
        observer.disconnect()
        const json = entry.toJSON()
        console.log('first-contentful-paint:', json)
        //上报数据
        const reqportData = {
          ...json,
          type: 'performance',
          subType: entry.name,
          pageUrl: window.location.href,
        }
        //上报数据
        lazyReportBatch(reqportData)
      }
    }
  }

  // 统计和计算fp时间
  const observer = new PerformanceObserver(entryhandler)
  //buffer:true 确保观察到所有的paint事件
  observer.observe({ type: 'paint', buffered: true })
}

import { lazyReportBatch } from '../report'
export default function observeFCP() {
  const entryhandler = (list) => {
    for (const entry of list.getEntries()) {
      if (entry.name === 'first-contentful-paint') {
        observer.disconnect()
        const json = entry.toJSON()
        console.log('first-contentful-paint:', json)
        //上报数据
        const reqportData = {
          ...json,
          type: 'performance',
          subType: entry.name,
          pageUrl: window.location.href,
        }
        //上报数据
        lazyReportBatch(reqportData)
      }
    }
  }

  // 统计和计算fp时间
  const observer = new PerformanceObserver(entryhandler)
  //buffer:true 确保观察到所有的paint事件
  observer.observe({ type: 'paint', buffered: true })
}

```

lcp

```js
import { lazyReportBatch } from '../report'
export default function observeLCP() {
  const entryHandler = (list) => {
    if (observer) {
      observer.disconnect()
    }
    for (const entry of list.getEntries()) {
      const json = entry.toJSON()
      console.log(json)
      const reportData = {
        ...json,
        type: 'performance',
        subType: entry.name,
        pageUrl: window.location.href,
      }
      // 发送数据 todo;
      lazyReportBatch(reportData)
    }
  }
  // 统计和计算lcp的时间
  const observer = new PerformanceObserver(entryHandler)
  // buffered: true 确保观察到所有paint事件
  observer.observe({ type: 'largest-contentful-paint', buffered: true })
}

```

 

fp

```js
export default function observePaint() {
  const entryHandler = (list) => {
    for (const entry of list.getEntries()) {
      if (entry.name === 'first-paint') {
        observer.disconnect()
        const json = entry.toJSON()
        console.log(json)
        const reportData = {
          ...json,
          type: 'performance',
          subType: entry.name,
          pageUrl: window.location.href,
        }
        // 发送数据 todo;
        lazyReportBatch(reportData)
      }
    }
  }
  // 统计和计算fp的时间
  const observer = new PerformanceObserver(entryHandler)
  // buffered: true 确保观察到所有paint事件
  observer.observe({ type: 'paint', buffered: true })
}

```

 

load  DomcontentLoad

```js
export default function observeLoad() {
  window.addEventListener('pageShow', function (event) {
    //页面重绘周期内上报
    requestAnimationFrame(() => {
      let typeArr = ['load', 'DomcontentLoad']
      typeArr.forEach((type) => {
        const reportData = {
          type: 'performance',
          subType: type,
          pageUrl: window.location.href,
          startTime: performance.now() - event.timeStamp,
        }
        console.error('performanceLoad', reportData)
        // 发送数据
        lazyReportBatch(reportData)
      })
    }, true)
  })
}

```

资源加载

```js

export default function observeEntries() {
  if (document.readyState === 'complete') {
    observerEvent()
  } else {
    const onLoad = () => {
      observerEvent()
      window.removeEventListener('load', onLoad, true)
    }
    window.addEventListener('load', onLoad, true)
  }
}

export function observerEvent() {
  const entryHandler = (list) => {
    const data = list.getEntries()
    for (let entry of data) {
      if (observer) {
        observer.disconnect()
      }

      const reportData = {
        name: entry.name, //资源的名
        type: 'performance', //类型
        subType: entry.entryType, //子类型
        sourceType: entry.initiatorType, // 资源类型
        duration: entry.duration, // 加载时间
        dns: entry.domainLookupEnd - entry.domainLookupStart, // DNS 解析时间
        tcp: entry.connectEnd - entry.connectStart, // TCP 连接时间
        redirect: entry.redirectEnd - entry.redirectStart, // 重定向时间
        ttfb: entry.responseStart, // 首字节时间
        protocol: entry.nextHopProtocol, // 请求协议
        responseBodySize: entry.encodedBodySize, // 响应内容大小
        responseHeaderSize: entry.transferSize - entry.encodedBodySize, // 响应头部大小
        transferSize: entry.transferSize, // 内容传输大小
        resourceSize: entry.decodedBodySize, // 资源解压后大小
        startTime: entry.startTime, // 开始时间
      }

      console.error('entrys', reportData)

      //TODO 数据上报
      lazyReportBatch(reportData)
    }
  }

  let observer = new PerformanceObserver(entryHandler)
  observer.observe({ type: ['resource'], buffered: true })
}

```

#####  错误信息统计

window.onerror() 监听js运行错误

error 监听静态资源加载错误

unhandlerejection 监听静态资源加载错误



行为信息统计

 页面的浏览器量数据统计 pv 

统计页面跳转

  一般我们都是单页面应用，监听hash change事件和propstate 事件

但是 `hash` 变化除了触发 `hashchange` ,也会触发 `popstate` 事件,而且会先触发 `popstate` 事件，我们可以统一监听 `popstate`



同时在 `History API` 中还有一个 `事件` ，该事件为 `popstate`;它有着以下**特点**;

- `History.back()`、`History.forward()`、`History.go()`在被**调用**时，会触发 `popstate事件`
- 但是`History.pushState()`和`History.replaceState()`不会触发 `popstate事件`。

所以我们需要对 `replaceState` 和 `pushState`，去**创建新的全局Event事件**。然后 `window.addEventListener` 监听我们加的 `Event` 即可



点击事件

统一监听mousedwon 事件

点击元素了才记录



框架错误统计

 vue  开发一个插件

使用vue的利用vue官方提供的统一错误管理机制，并开发一个插件

```js
export function install(Vue, options) {
  if (__webEyeSDK__.vue) return

  __webEyeSDK__.vue = true

  setConfig(options)
  const handler = Vue.config.errorHandler
  Vue.config.errorHandler = function (err, vm, info) {
    // 上报具体的错误信息
    const reportData = {
      info,
      error: err.stack,
      subType: 'vue',
      type: 'error',
      startTime: window.performance.now(), //高精度时间戳测量短时间间隔的精确时间。
      pageUrl: window.location.href,
    }
    lazyReportBatch(reportData)
    if (handler) {
      handler.call(this, err, vm, info)
    }
  }

```

react

```js

export function errorBoundary(err, info) {
  if (__webEyeSDK__.react) return
  __webEyeSDK__.react = true
  // 上报错误信息
  reportData = {
    error: err?.stack,
    info,
    subType: 'react',
    type: 'error',
    startTime: window.performance.now(), //高精度时间戳测量短时间间隔的精确时间。
    pageUrl: window.location.href,
  }
  //上报数据错误信息T
  lazyReportBatch(reportData)
}

```

#### SDK 如何实现会话级别的错误上报去重？

 生成错误id的作用， 在客户端用于实现会话级别的上报去重，在服务端生成相同 数据的错误的聚合

- 在用户的`一次会话`中，如果产生了同一个错误，那么将这同一个错误`上报多次`是`没有意义`的；
- 在用户的`不同会话`中，如果产生了同一个错误，那么将不同会话中产生的错误`进行上报`是`有意义`的；

为啥？

- 在用户的同一次会话中，如果点击一个按钮出现了错误，那么再次点击同一个按钮，必定会出现同一个错误，而这出现的多次错误，影响的是同一个用户、同一次访问；所以将其全部上报是没有意义的；

- 而在同一个用户的不同会话中，如果出现了同一个错误，那么这不同会话里的错误进行上报就显得有意义了；

```js
// 对每一个错误详情，生成一串编码
export const getErrorUid = (input: string) => {
  return window.btoa(unescape(encodeURIComponent(input)));
};

```

输入一个字符串，将其编码为一个base64字符串，用于唯一表示错误详情。

```text
encodeURIComponent：

将输入字符串转为URI编码，确保所有字符都被安全编码。
unescape：

解码之前的URI编码。因为 window.btoa 需要纯ASCII字符串，而 encodeURIComponent 编码的结果中有非ASCII字符（如 %xx 格式），需要用 unescape 转回纯ASCII字符。
window.btoa：

将结果编码为Base64字符串。
```

在错误信息中我们可以根据，产生的信息，行，列，错误文件来进行怕断是否是相同的错误，根据上述信息生成唯一的hash值，来描述错误的唯一性。

#### SDK  采用什么样的上报策略？如何实现异常隔离？

 数据上报： 

**Ajax**

Img  gif 

 **Img** 没有跨域限制，像script标签，img标签都可以直接发送跨域的get请求，不用特殊的特殊处理

兼容性好，一些静态页面可能禁用了脚本，这时候script脚本就不能使用了。1*1 GIF 体积小， 透明， 只是传递数据，借助了img src 标签的属性，参数拼接在url后面，服务端收到后再进行解析

 img 加载解析后并不会渲染，等待渲染树构建完成后一起渲染。 

**sendBeacon**

Navigator.sendbeacon() 通用的埋点上报方案，通过http，post 方法将少量的数据上上传给服务器

sendBeacon是一异步的不会影响当前页面的跳转到下一个页面的跳转，且不受同域限制， 请求当前页面脱离关系，作为浏览器任务，可以保证任务发出来，不受拖延卸载流程

sendBeacon传输数据更加的规范，传输流程更加的规范

原理： 成功进入浏览器队列后会返回true，若受到队列总数，和数据的大小限制后， 会返回false. true只是代表从新进入队列，表示浏览器尽力发送。成功是否未知，不再有任何返回值。



方案：  优先选sendBeacon，但是若数据量超过了的sendBeacon的限制，就降级为xhr进行数据上报

原因： 并不所有的浏览器都完全支持sendBeacon ，我们需要一个兜底的方案，sendBeacon 不能传输大量的数据信息，这个时候要还要ajax

为啥不适用img呢？ 跨域怎么办呢？

img是以get的方式上传数据的， 上传的数据拼接到请求的URL中，而浏览器，代理服务器对url的长度有限制，规范对URL的长度，并没有要求，导致有些请求参数会发送不全面。 

跨域问题由服务端来解决

**异常隔离**

 暴力反方法就是把整个sdk 都用try catch 进行包括起来，即使出现错误，也在catch里面直接拦截下

问题：

- 只获取报错信息，无法获得报错位置，插件
- 没上报，感知sdk产生了错误
- 无法获取sdk出错的一个环境数据

解决方案：

- 每一个插件模块都用try catch包括起来，然后当抛出错误的时候进行数据的封装和上报，这样就完成了一个异常隔离机制
-  SDK产生异常的时候，会进行数据的上报 
- 出现异常终止SDK的运行，并移除所有的事件监听
